Ok, bạn vừa gửi flow chi tiết của Use Case: View Upcoming Matches (Fixtures). Mình sẽ phân tích và giải thích lại, đồng thời liên kết với code bạn đã có để bạn thấy mọi thứ khớp nhau như thế nào.

1️⃣ Goal

Mục tiêu:
Người dùng muốn xem danh sách các trận đấu sắp diễn ra (upcoming fixtures) với tùy chọn filter: mô tả trận, cầu thủ, CLB, mùa giải.
Hệ thống trả về HTML đã render (Fixture.html) với kết quả lọc.

2️⃣ Entry Point (HTTP Request)
GET /match/fixture?search=xxx&searchPlayerName=yyy&searchClubName=zzz&season=2025


Browser gửi request kèm các query param (có thể để trống).

Mỗi param sẽ được Controller xử lý nếu tồn tại.

3️⃣ Controller Layer — MatchController

Nhận các tham số thô từ request:

@GetMapping("/fixture")
public String getFixture(
@RequestParam(name="search", required=false) String search,
@RequestParam(name="searchPlayerName", required=false) String searchPlayerName,
@RequestParam(name="searchClubName", required=false) String searchClubName,
@RequestParam(name="season", required=false) String season,
Model model)


Trách nhiệm:

Gửi params đến Service để lấy danh sách trận đã lọc.

Gắn danh sách và các giá trị filter trở lại model.addAttribute(...).

Trả về view name "Fixture" để Thymeleaf render.

4️⃣ Service Layer — MatchService

Method: getUpcomingFiltered(search, searchPlayerName, searchClubName, season)

Trách nhiệm:

Chuẩn hóa input (trim, convert empty string → null)

Parse season thành số nguyên

Lấy LocalDateTime.now() một lần → dùng trong filter DB

Gọi repository với các tham số đã chuẩn bị

Code mẫu:

public List<Match> getUpcomingFiltered(...) {
String s = (search != null && !search.isBlank()) ? search.trim() : null;
...
int year = parseSeason(season); // parse safely
LocalDateTime now = LocalDateTime.now();
return matchRepo.findUpcomingFiltered(now, year, s, playerName, clubName);
}

5️⃣ Repository Layer — MatchRepo

Method: findUpcomingFiltered(...)

Trách nhiệm JPQL:

m.matchStartTime > :now → chỉ các trận sắp diễn ra

Optional predicates nếu param không null

Join:

m.matchPlayerStats mps → mps.player p để filter theo player

m.matchClubStats mcs → mcs.club c để filter theo club

DISTINCT → tránh trùng do join

Order by startTime ascending

Logic giống bạn đang làm, nhưng ở đây filter DB-side → hiệu năng tốt hơn, không load tất cả match về rồi filter Java.

6️⃣ Domain Model (Entities)

Match → MatchPlayerStat → Player

Match → MatchClubStat → Club

Truy vấn filter dựa trên các quan hệ này.

Đây là cơ sở để lọc theo cầu thủ, CLB, mùa giải mà không phải viết nhiều nested loops trong Java.

7️⃣ View Layer — Fixture.html

Nhận matches từ model

Lặp qua danh sách với th:each

Hiển thị matchDescription và matchStartTime

Form GET filter có thể resubmit → stateless refresh

<ul th:each="m : ${matches}">
    <li><span th:text="${m.matchDescription}"></span> - <span th:text="${m.matchStartTime}"></span></li>
</ul>


Giữ lại giá trị input:

<input name="searchPlayerName" th:value="${searchPlayerName}" />

8️⃣ Data Flow Sequence (Linear)

User hits /match/fixture

Controller nhận param → gọi Service

Service chuẩn hóa → gọi Repository

Repository truy vấn DB → trả List<Match>

Controller addAttribute → Thymeleaf render

9️⃣ Coupling Summary

Controller → Service → Repository → JPA/Entities

View → Controller (model attributes)

Không có business logic ở View, không parse param ở Repository, không persist ở Controller

10️⃣ Key Considerations

Filtering ở DB-side → tiết kiệm bộ nhớ

Joins dùng left join để tolerate missing stats

Có thể nâng cấp với pagination

Indexes:

match_start_time

player_full_name

club_name

11️⃣ Responsibility Boundaries
Layer	Responsibility
View	Chỉ hiển thị dữ liệu (matches), giữ form input
Controller	Nhận params, addAttribute, gọi Service
Service	Normalize inputs, orchestration, parse season, call repository
Repository	Thực thi JPQL, chỉ lọc DB, không logic business